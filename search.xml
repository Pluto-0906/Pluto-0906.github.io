<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>保研前学习历程记录</title>
    <url>/2022/03/11/%E4%BF%9D%E7%A0%94%E5%89%8D%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>想到需要写下这篇文章的时候是2022年3月11日，此时的我大抵是能拿到学校的保研资格了，经历了大学两年半的学习生活，目前的结果暂时是不错的，但是在我面前的还有两座大山，夏令营和预推免，希望靠着每天记录一点当日所学知识，来记录自己点滴的进步，并且更加督促自己前进。我也很期待半年后自己的最终归宿，<strong>就像海贼王的故事一样，究竟是怎样的结局，才配得上这一路的“颠沛流离”~</strong></p>
<h2 id="三月记">三月记</h2>
<h3 id="section">2022-3-11</h3>
<p>开学以来最充实的一天无疑了~</p>
<ol type="1">
<li>MIT线性代数两讲：正交矩阵和施密特正交化、行列式及其性质，每次学习过程都不得不感叹这门课真的教的太好了！</li>
<li>基本上看完了同济子豪兄所讲授的cs231n课程，让我的深度学习基础也更加牢固了，但是一些细节方面的知识还需要多看看博客和书籍来进行锤炼，目前也已经准备了两本书：邱锡鹏：《神经网络与深度学习》、《百面深度学习》</li>
<li>AcWing算法课程：prim算法与Kruskal算法的听讲与代码实现。yysy，在图论这一章节真的花费了好多时间，只能说之前算法与数据结构的基础有点差了，希望在后面能不断通过刷题来弥补~</li>
</ol>
<h3 id="section-1">2022-3-12</h3>
<p>相当摸鱼的一天，跟好友外面吃了饭，回来又看完了蜘蛛侠：英雄无归，但还是很快乐的hhh</p>
<ol type="1">
<li>MIT线性代数一讲：行列式公式和代数余子式，从行列式permutation的角度来讲述了公式的推导过程，这部分由于国内应试教育的注重，之前的记忆还是比较深刻的，所以并不是很难，不过GS最后的一个例子还是很有趣的，一个行列式值的递推~</li>
<li>结束了图论章节，学习了染色法判定二分图和匈牙利算法，再次被dfs虐，递归还是没学好。。。总结图论这一章，感觉要无数次回顾了~还是太菜了555；开启了数论这一章，目前已经学了质数部分：试除法、分解质因数、筛质数，感觉相比图论简单，但估计刚开始的原因。。。</li>
</ol>
<h3 id="section-2">2022-3-13</h3>
<ol type="1">
<li>MIT线性代数两讲：克拉默法则、逆矩阵、体积，特征值和特征向量，怎么说呢，这两讲听得有点云里雾里的，可能还是要好好消化一下，主要收获就是**以3*3行列式为例子，它的值是按照矩阵行向量为边的平行六面体的体积**。当然也看到一篇写的非常好的文章:<a href="https://blog.csdn.net/myan/article/details/647511">理解矩阵</a>,形象的阐释了矩阵的本质就是一种线性空间内的变换，跟之前3blue1brown那里讲授的有异曲同工之妙~</li>
<li>复习了一点os进程，主要是为了重修课的作业。。。</li>
<li>AcWing加入了春季每日一题活动，并且AC了第一题<a href="https://www.acwing.com/problem/content/3349/">3346. 你知道你的ABC吗</a></li>
</ol>
<h3 id="section-3">2022-3-14</h3>
<ol type="1">
<li>AC了力扣每日一题<a href="%5B599.%20两个列表的最小索引总和%5D(https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/)">599.两个列表的最小索引总和</a>，是一道比较典型的哈希表模拟问题，并不是很难，顺便发现了<a href="https://github.com/SharingSource/LogicStack-LeetCode/wiki">宫水三叶的刷题笔记</a>，很幸运，一直想针对Acwing学习进行相应tag强化~</li>
<li>MIT 线性代数一讲：对角化和矩阵的幂，终于明白了高中数列的特征根方程是什么以及如何通过对角化简化计算</li>
<li>408操作系统复习，复习完了进程调度算法已经进程同步与互斥实现两部分，并且完成了OS重修班的作业</li>
<li>AcWing每日一题<a href="https://www.acwing.com/problem/content/3361/">3358. 放养但没有完全放养</a>AC</li>
<li>AcWing跳过数论这一章，开始先看DP，目前看完了0-1背包</li>
</ol>
<h3 id="section-4">2022-3-15</h3>
<ol type="1">
<li>dp是真的难，尤其是优化。。。目前看完了基础课的四个背包问题，还在持续消化中，打算写一篇背包问题的学习笔记记录一下，目前写完了0-1背包问题</li>
<li>力扣每日一题[<a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目</a>,用位运算AC了</li>
</ol>
<h3 id="section-5">2022-3-16</h3>
<ol type="1">
<li>完成了之前国奖所要求的个人事迹书写。。。真的太难写了，花费了一个下午</li>
<li>搞定了博客无法显示数学公式的坑，搞定了typora转知乎格式，并且强烈吐槽知乎垃圾编辑器。。。体验太糟糕了</li>
</ol>
<h3 id="section-6">2022-3-17</h3>
<p>啥也没干，今天杭州天气太差，没去图书馆，开摆了一天，随便写了两道PAT。。。明天开始干活。。。</p>
]]></content>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路算法</title>
    <url>/2022/03/06/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前要知识">前要知识</h2>
<ul>
<li>n为点数，m为边数</li>
<li>在图论中，无向图其实可以看成是一种特殊的有向图，连一条A-&gt;B的边，再连一条B-&gt;A的边即可</li>
<li>稠密图用邻接矩阵来存储，稀疏图用邻接表来存储（根据题目数据范围进行判断，当m与<span class="math inline">\(n^2\)</span>一个级别时，即为稠密图；当m与n一个级别时即为稀疏图）</li>
</ul>
<h2 id="知识结构">知识结构</h2>
<figure>
<img src="https://s2.loli.net/2022/03/06/bquCZBsiNtPQWn5.png" alt="最短路知识结构" /><figcaption aria-hidden="true">最短路知识结构</figcaption>
</figure>
<h2 id="朴素dijkstra算法">朴素Dijkstra算法</h2>
<p>Dijkstra的整体思路比较清晰：即进行n（n为点的个数）次迭代去确定每个点到起点的最小值，每次迭代中确定一个点，最后输出的终点即为我们要找的最短路的距离。</p>
<p>Dijkstra算法是基于贪心的，有关算法的具体解释可以参考这一篇博客：<a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra">图最短路径算法之迪杰斯特拉算法（Dijkstra）</a></p>
<h3 id="题目">题目</h3>
<figure>
<img src="https://s2.loli.net/2022/03/06/CEw9lKNm2Bqx35a.png" alt="AcWing849" /><figcaption aria-hidden="true">AcWing849</figcaption>
</figure>
<h3 id="思路">思路</h3>
<p>对于重边和自环的处理：由于边权值都是正数，所以哪怕存在自环，也不会对结果产生影响，对于重边的处理，可以在输入时进行判断，取最小值即可。</p>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];    <span class="comment">// 为稠密阵所以用邻接矩阵存储</span></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">// 用于记录每一个点距离第一个点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 用于记录该点的最短距离是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);     <span class="comment">// 初始化距离，0x3f代表无限大</span></span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 第一个点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)      <span class="comment">// 有n个点所以要进行n次迭代</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;       <span class="comment">// t存储当前访问的点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)   <span class="comment">//这里的j代表的是从1号点开始</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))  <span class="comment">// 找到当前距离最小的点加入确认点集合中    </span></span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j++)           <span class="comment">//依次更新每个点所到相邻的点路径值</span></span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//如果第n个点路径为无穷大即不存在最低路径</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);    <span class="comment">//初始化图 因为是求最短路径，所以每个点初始为无限大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z);     <span class="comment">//如果发生重边的情况则保留最短的一条边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆优化版dijkstra算法">堆优化版Dijkstra算法</h2>
<h3 id="题目-1">题目</h3>
<figure>
<img src="https://s2.loli.net/2022/03/06/sqQAv6HImGefly5.png" alt="AcWing850" /><figcaption aria-hidden="true">AcWing850</figcaption>
</figure>
<h3 id="思路-1">思路</h3>
<p>参考这俩位大佬的解法笔记：</p>
<ol type="1">
<li><a href="https://www.acwing.com/solution/content/6291/">小呆呆</a></li>
<li><a href="https://www.acwing.com/solution/content/6554/">optimjie</a></li>
</ol>
<h3 id="代码-1">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>; <span class="comment">// 把N改为150010就能ac</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稀疏图用邻接表来存</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// 用来存权重</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 如果为true说明这个点的最短路径已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[idx] = c; <span class="comment">// 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中</span></span><br><span class="line">    e[idx] = y; <span class="comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并</span></span><br><span class="line">    ne[idx] = h[x]; <span class="comment">// 标记st为true，所以下一次弹出3+x会continue不会向下执行。</span></span><br><span class="line">    h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="comment">// 定义一个小根堆</span></span><br><span class="line">    <span class="comment">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时    </span></span><br><span class="line">    <span class="comment">// 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123; <span class="number">0</span>, <span class="number">1</span> &#125;); <span class="comment">// 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序</span></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII k = heap.<span class="built_in">top</span>(); <span class="comment">// 取不在集合S中距离最短的点</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = k.second, distance = k.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i]; <span class="comment">// i只是个下标，e中在存的是i这个下标对应的点。</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123; dist[j], j &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(x, y, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bellman_ford算法">Bellman_Ford算法</h2>
<h3 id="题目-2">题目</h3>
<figure>
<img src="https://s2.loli.net/2022/03/06/jwAGZIXCpSEsaLY.png" alt="AcWing853" /><figcaption aria-hidden="true">AcWing853</figcaption>
</figure>
<h3 id="思路-2">思路</h3>
<ul>
<li><p>该算法适合处理带有负权边的题目，尤其是带有<strong>最多经过k条边</strong>这样条件的题目</p></li>
<li><p>除此之外，该算法还可以判断图中是否存在负环，具体判断操作如下：</p>
<p>算法经过<span class="math inline">\(V - 1\)</span>次松弛迭代过后，如果从源点到各点距离还存在变化，那就说明必定存在负环</p></li>
<li><p>算法最多经过k条边如何在代码中进行体现？只需要让最外层循环次数为k即可！经过模拟，个人认为这个算法的松弛过程有点类似于BFS的逐步扩散过程</p></li>
<li><p>在每一次松弛过程中，需要先让先前一次迭代过程后的距离数组备份，防止出现串联现象！</p></li>
</ul>
<p>可以参考的题解和博客：</p>
<ol type="1">
<li><a href="https://www.acwing.com/solution/content/14088/">松鼠爱葡萄</a></li>
<li><a href="https://www.jianshu.com/p/b876fe9b2338">数据结构（十一）：最短路径(Bellman-Ford算法)</a></li>
</ol>
<h3 id="代码-2">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N], backup[N];	<span class="comment">// 注意定义备份距离数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接开个结构体来存边</span></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)  <span class="comment">// 松弛k轮</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dist, backup, <span class="keyword">sizeof</span> dist);	<span class="comment">// 备份</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dist[b] &gt; backup[a] + w)	<span class="comment">// 迭代松弛</span></span><br><span class="line">                dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意这里为什么是 0x3f3f3f3f / 2 ? </span></span><br><span class="line">    <span class="comment">// 因为总共k次松弛，假设某个点一直被它周围的某个点松弛（负权边）并且负权边最小为-10000</span></span><br><span class="line">    <span class="comment">// 并且k最大为500，那么最多会减少5000000，还是满足大于0x3f3f3f3f / 2</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, w;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        edges[i] = &#123;x, y, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd算法">Floyd算法</h2>
<h3 id="题目-3">题目</h3>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>布鲁托的力扣记录001—组合</title>
    <url>/2022/03/18/%E5%B8%83%E9%B2%81%E6%89%98%E7%9A%84%E5%8A%9B%E6%89%A3%E8%AE%B0%E5%BD%95001%E2%80%94%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>一直以来都有写题解的想法，今天在此付诸实践，这是个人对于力扣刷题记录的第一篇，偏向于对AcWing学习的补充与强化，希望能够记录自己的进步~</p>
<h2 id="题目">题目</h2>
<p><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></p>
<h2 id="思路">思路</h2>
<p>这道题是回溯问题中比较经典的组合问题，可以将问题转化为一个多叉树进行解决，有固定的的代码模板，可以参考这里：<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF">代码随想录：回溯法模板</a></p>
<h2 id="代码">代码</h2>
<h3 id="未剪枝">未剪枝</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; comb;</span><br><span class="line">        <span class="built_in">backtracking</span>(res, comb, <span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt; comb, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> stIdx, <span class="type">const</span> <span class="type">int</span>&amp; n, <span class="type">const</span> <span class="type">int</span>&amp; k)</span>  <span class="comment">// stIdx用来记录本层递归中，集合从哪里开始遍历</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(comb.<span class="built_in">size</span>() == k) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(comb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = stIdx; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            comb.<span class="built_in">push_back</span>(i);  <span class="comment">// 处理现场</span></span><br><span class="line">            <span class="built_in">backtracking</span>(res, comb, i + <span class="number">1</span>, n, k);</span><br><span class="line">            comb.<span class="built_in">pop_back</span>();  <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对于stIdx的解释：</strong></p>
<p>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠这个stIdx</p>
<h3 id="剪枝">剪枝</h3>
<p><strong>剪枝思路：</strong></p>
<p><img src="https://s2.loli.net/2022/03/18/5JuczsbgNIV4oeG.png" /></p>
<p>当n = 4, k = 4时，外层的for循环从stIdx = 2开始其实是没有必要进行的，因为接下来的所有情况都没有办法达到所要求的组合个数k，所以可以直接剪枝；同理，在递归过程中也有不需要进行的步骤，如上图所示。</p>
<p>所以我们就可以对for循环进行优化，本质就是<strong>加上判断条件/缩小遍历范围提前结束递归</strong>，考虑在遍历过程中，我们总共需要k个，现在某个时刻已经有了comb.size()个，那么还需要k-comb.size()个，那么此时的stIdx最大也不能超过n - (k - comb.size()) + 1，否则就根本达不到k个的要求，按上述分析进行剪枝操作，便可得到一下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; comb;</span><br><span class="line">        <span class="built_in">backtracking</span>(res, comb, <span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt; comb, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> stIdx, <span class="type">const</span> <span class="type">int</span>&amp; n, <span class="type">const</span> <span class="type">int</span>&amp; k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(comb.<span class="built_in">size</span>() == k) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(comb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = stIdx; i &lt;= n - (k - comb.<span class="built_in">size</span>()) + <span class="number">1</span>; i++)  <span class="comment">// 剪枝</span></span><br><span class="line">        &#123;</span><br><span class="line">            comb.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracking</span>(res, comb, i + <span class="number">1</span>, n, k);</span><br><span class="line">            comb.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="举一反三">举一反三</h2>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p></li>
<li><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></p></li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%89%E9%83%A8%E6%9B%B2">代码随想录：组合问题</a></p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2022/03/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>本文将基于各大优质博客题解并加之个人的总结，主要内容包括四类背包问题：0-1背包问题，完全背包问题，多重背包问题和分组背包问题。</p>
<h2 id="背包问题">0-1背包问题</h2>
<h3 id="题目"><a href="https://www.acwing.com/problem/content/2/">题目</a></h3>
<p><img src="https://s2.loli.net/2022/03/15/iHIsfmYt1lOGJvP.png" /></p>
<h3 id="题解代码">题解代码</h3>
<h4 id="二维版本">1. 二维版本</h4>
<p>状态<span class="math inline">\(f[i][j]\)</span>定义：前 <span class="math inline">\(i\)</span> 个物品（包括 <span class="math inline">\(i\)</span> ），背包容量 <span class="math inline">\(j\)</span> 下的最优解（最大价值）</p>
<p>根据在背包容量为 <span class="math inline">\(j\)</span> 的情况下是否选取物品 <span class="math inline">\(i\)</span> ，可以求得状态转移方程为： <span class="math display">\[
f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])
\]</span> <strong>含义:</strong></p>
<ol type="1">
<li><p>如果不装第 <span class="math inline">\(i\)</span> 件物品，那么问题就转化为“前 <span class="math inline">\(i-1\)</span> 件物品放入容量为 <span class="math inline">\(j\)</span> 的背包中的最大价值”</p></li>
<li><p>如果装第 <span class="math inline">\(i\)</span> 件物品，那么问题就转化为“前 <span class="math inline">\(i-1\)</span> 件物品放入剩下的容量为 <span class="math inline">\(j-v[i]\)</span> 的背包中的最 大价值”</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一维版本">2. 一维版本</h4>
<p>观察原来的状态转移方程由于原来的<span class="math inline">\(f[i][j]\)</span>都是由它左上角的状态更新过来的，并且仅由<span class="math inline">\(f[i-1]\)</span>这一层状态更新，所以我们可以采用滚动数组的形式，也就是相当于总共就两行状态，第二行状态由第一行状态更新，第一行状态又由第二行状态更新，如此循环。最后，我们可以将二维数组压缩成一维数组。</p>
<p>我们将原来状态转移方程第一维抹除<strong>（但是你脑子里得当做它存在）</strong>，此时的状态转换方程为： <span class="math display">\[
f[j] = max(f[j], f[j - v[i]] + w[i])
\]</span> 此时 <span class="math inline">\(f[j]\)</span> 的含义：背包容量 <span class="math inline">\(j\)</span> 下的最优解（最大价值）</p>
<p>此时我们得关注遍历顺序，<strong><span class="math inline">\(i\)</span> 在外层，<span class="math inline">\(j\)</span> 在内层，并且 <span class="math inline">\(j\)</span> 需要逆序遍历！</strong>具体原因可以看这篇题解<a href="https://www.acwing.com/solution/content/3982/">01背包问题 一维动态规划状态转移方程的解释</a></p>
<p>此时我们可以采取第一步优化（此处可参考题解<a href="https://www.acwing.com/solution/content/1374/">01背包问题（状态转移方程讲解）</a>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];  <span class="comment">// 优化前</span></span><br><span class="line">            f[j] = f[j];            <span class="comment">// 优化后，该行自动成立，可省略。</span></span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);  <span class="comment">// 优化前</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);                   <span class="comment">// 优化后</span></span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>
<p>实际上，只有当枚举的背包容量 <span class="math inline">\(&gt;=v[i]\)</span> 时才会更新状态，因此我们可以修改循环终止条件进一步优化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)  </span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>最终我们可以得到一维版本的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j -- )</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包问题">完全背包问题</h2>
<h3 id="题目-1"><a href="https://www.acwing.com/problem/content/3/">题目</a></h3>
<p><img src="https://s2.loli.net/2022/03/16/RswkKalOpAFqrQG.png" /></p>
<h3 id="题解代码-1">题解代码</h3>
<h4 id="二维版本-1">1. 二维版本</h4>
<p>状态 <span class="math inline">\(f[i][j]\)</span> 的定义与0-1背包是一样的，都是指：前<span class="math inline">\(i\)</span>个物品（包括 <span class="math inline">\(i\)</span> ），背包容量 <span class="math inline">\(j\)</span> 下的最优解（最大价值）</p>
<p>首先画出<strong>y氏思考流程图：</strong><img src="https://s2.loli.net/2022/03/16/EbzF5YZSHhuIdQf.png" /></p>
<p>画出这张图之后，就可以比较容易写出以下代码了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j / v[i]; k++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一维版本-1">2. 一维版本</h4>
<p>以下部分主要取自<a href="https://www.acwing.com/solution/content/5345/">Charles__的题解</a>，很感谢他的题解，让我弄懂了优化的思路~</p>
<p>我们考虑以下两个式子的递推方程： <span class="math display">\[
f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w ,  f[i-1,j-2*v]+2*w , f[i-1,j-3*v]+3*w , .....)
\]</span></p>
<p><span class="math display">\[
f[i , j-v]= max(            f[i-1,j-v]   ,  f[i-1,j-2*v] + w , f[i-1,j-3*v]+2*w , .....)
\]</span></p>
<p>以上两个式子我们可以对比发现<span class="math inline">\(f[i][j - v]\)</span>就是<span class="math inline">\(f[i][j]\)</span>中除了第一项以外的项<span class="math inline">\(+w\)</span>，那么我们就可以将最终的状态转移方程简化为： <span class="math display">\[
f[i][j]=max(f[i-1][j], f[i,j-v]+w)
\]</span> 于是我们便可以对代码进行修改，我们首先可以去掉最内层的for循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j - v[i] &gt;= <span class="number">0</span>)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这一步，其实跟0-1背包已经很像了，直接去掉一维，得到以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j++)  <span class="comment">// 注意这里必须是正序遍历！</span></span><br><span class="line">		f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br></pre></td></tr></table></figure>
<p><strong>对于遍历顺序的解释说明：</strong></p>
<p>我们发现这里的第二层循环和0-1背包是相反的，可以这样来理解，首先来看一下两者最终的状态转换方程：</p>
<p><strong>0-1背包：</strong> <span class="math display">\[
f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])
\]</span> <strong>完全背包：</strong> <span class="math display">\[
f[i][j]=max(f[i-1][j], f[i,j-v]+w)
\]</span> 只有一个区别，注意两者第二个下标，由于是采用滚动数组的形式优化，完全背包是<span class="math inline">\(i\)</span>，说明用到的是当层已经完成更新的先前状态去更新当层正在更新的状态，而0-1背包是<span class="math inline">\(i-1\)</span>，说明是上层的状态去更新当层的状态，所以说完全背包需要的是正序，而0-1是逆序！</p>
<p>最终得到一维版本完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j++)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.acwing.com/solution/content/3982/">01背包问题 一维动态规划状态转移方程的解释</a></li>
<li><a href="https://www.acwing.com/solution/content/1374/">01背包问题（状态转移方程讲解）</a></li>
<li><a href="https://www.acwing.com/solution/content/5345/">Charles__的题解</a></li>
</ul>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2022/03/07/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>在开始这篇文章之前，首先转载一篇我个人认为写的非常好的博客：<a href="https://lyl0724.github.io/2020/01/25/1/">三道题套路解决递归问题</a>，希望在读我这篇文章之前大家<strong>一定要先去看一看。</strong>我非常感谢这篇博客的帮助，正是它打开了我对递归理解的大门，让我不再只会用递归写求解斐波那契数列[dog]。</p>
<p>本篇文章主要是为了记录我自身对递归的理解，也会集合百家之长，所以引用参考的所有博客希望大家都要去看一看，<strong>我将会持续更新！</strong></p>
<h2 id="递归解题三部曲">递归解题三部曲</h2>
<ol type="1">
<li><strong>找整个递归的终止条件：递归应该在什么时候结束？</strong></li>
<li><strong>找返回值：应该给上一级返回什么信息？</strong></li>
<li><strong>本级递归应该做什么：在这一级递归中，应该完成什么任务？</strong></li>
</ol>
<h2 id="个人终极理解">个人终极理解</h2>
<p><strong>递归函数就是黑盒</strong>，我们只需要关注它所实现的功能即可，至于具体的实现过程，那交给计算机自己去处理吧！</p>
<p>而我们在求解过程中，最需要培养的是什么？<strong>抽象</strong>！</p>
<p>接下来将会用题目辅助理解！</p>
<h2 id="二叉树类型题目">二叉树类型题目</h2>
<p>二叉树问题是非常典型的可以用递归解决的问题，这里再推荐两篇非常优秀的题解/题单：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">一篇文章带你吃透对称性递归(思路分析+解题模板+案例解读)</a></li>
<li><a href="https://juejin.cn/post/7018181330596790285">字节高频算法题，面试必考之递归算法解题套路</a></li>
</ul>
<p>可以试着练一练手~</p>
<p>根据前面所提到第一篇题解中大佬总结的规律，对称性递归问题可以分成两类：</p>
<ol type="1">
<li>不需要构造辅助函数
<ul>
<li>单树问题</li>
<li>双树问题</li>
</ul></li>
<li>需要构造辅助函数</li>
</ol>
<p>在此引用一下大佬总结的<strong>解题模板</strong></p>
<ol type="1">
<li><p>递归结束条件：特殊情况的判断</p>
<ul>
<li><p>单树问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;</span><br></pre></td></tr></table></figure></li>
<li><p>双树问题（根节点分别为p,q）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p &amp;&amp; !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!p || !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>当然也不完全是这些情况，比如有的需要加上节点值的判断，需要具体问题需要具体分析</p></li>
</ul></li>
<li><p>返回值</p>
<p>通常通常对称性递归的返回值是多个条件的复合判断语句，可能是以下几种条件判断的组合：</p>
<ul>
<li>节点非空的判断</li>
<li>节点值的比较</li>
<li>(单树)调用根节点左右子树的递归函数进行递归判断</li>
<li>(双树)调用两棵树的左右子树的递归函数进行判断</li>
</ul></li>
</ol>
<p>以下将会用题目来方便大家掌握理解，也是一个<strong>参考练手题单</strong>，希望大家先自己做题，这样收获很大！</p>
<h3 id="无需构造辅助函数">无需构造辅助函数</h3>
<h4 id="相同的树"><a href="https://leetcode-cn.com/problems/same-tree/">100.相同的树</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 纯模板题，首先判断树的根节点情况，然后再其判断左右子树情况</span></span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (p -&gt; val == q -&gt; val) &amp;&amp; <span class="built_in">isSameTree</span>(p -&gt; left, q -&gt; left) &amp;&amp; <span class="built_in">isSameTree</span>(p -&gt; right, q -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的最大深度"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root -&gt; left), <span class="built_in">maxDepth</span>(root -&gt; right)) + <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉树"><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110.平衡二叉树</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root) == <span class="number">-1</span> ?  <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span> || right == <span class="number">-1</span> || <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="单值二叉树"><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">965.单值二叉树</a></h4>
<p>其实这个题解跟大多数人的还是不太一样的，我的做法是一种<strong>自底向上</strong>的过程，得弄清楚函数返回值的含义，返回的是当前左右子树是否为单值二叉树，也就是return的最后两个条件。然后你只需要判断当前根节点和其左右节点的值是否相同，这里有个比较trick的地方是前两个条件的写法，意思是如果左右子树为空，那么直接返回true，然后再判断不空的情况下值的情况，主要是前两个条件相对比较难写~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode*root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> (!root-&gt;left || root-&gt;left-&gt;val == root-&gt;val) &amp;&amp; (!root-&gt;right || root-&gt;right-&gt;val == root-&gt;val) &amp;&amp; <span class="built_in">isUnivalTree</span>(root-&gt;left) &amp;&amp; <span class="built_in">isUnivalTree</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面给出<strong>自顶向下</strong>的题解，也就是先判断当前点是否符合，然后再看它的左右节点所代表的的子树是否符合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((root-&gt;left &amp;&amp; root-&gt;left-&gt;val != root-&gt;val) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val != root-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isUnivalTree</span>(root-&gt;left) &amp;&amp; <span class="built_in">isUnivalTree</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="翻转二叉树"><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226.翻转二叉树</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || !root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* tmp = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;right = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        root-&gt;left = tmp;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="需要构造辅助函数">需要构造辅助函数</h3>
<h4 id="另一颗树的子树"><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572.另一颗树的子树</a></h4>
<p>这个题目虽然难度是简单，但个人认为是目前为止最难的一题了，<strong>很值得做一下！</strong></p>
<p>以下代码取自<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ke-shu-de-zi-shu-di-gui-by-trave-chyb/">traveller-lzx</a>大佬，个人认为最好理解~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果两个都为空</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>&amp;&amp;subRoot==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果只有一个为空</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>||subRoot==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果两个都不空，结点值也不同，那直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val!=subRoot-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果现在结点值和子树结点值相同，再分别检查两个的左右孩子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, subRoot-&gt;left) &amp;&amp; <span class="built_in">compare</span>(root-&gt;right, subRoot-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果要检查的子树为空，那么不用查了，肯定对的</span></span><br><span class="line">        <span class="keyword">if</span>(subRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果要检查的子树不空，但root是空的，那也不用查了，错的。</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要么是它本身，要么是它左子树，要么是它的右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root, subRoot) || <span class="built_in">isSubtree</span>(root-&gt;left, subRoot) || <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr />
<p>To be continued~</p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法思想</tag>
      </tags>
  </entry>
</search>
