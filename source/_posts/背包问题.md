---
title: 背包问题
date: 2022-03-15 17:57:08
tags: 动态规划
categorie: 算法笔记
mathjax: true
---

## 前言

本文将基于各大优质博客题解并加之个人的总结，主要内容包括四类背包问题：0-1背包问题，完全背包问题，多重背包问题和分组背包问题。

## 0-1背包问题

### [题目](https://www.acwing.com/problem/content/2/)

![](https://s2.loli.net/2022/03/15/iHIsfmYt1lOGJvP.png)

### 题解代码

#### 1. 二维版本

​		状态$f[i][j]$定义：前$i$个物品（包括 $i$ ），背包容量 $j$ 下的最优解（最大价值）

​		根据在背包容量为 $j$ 的情况下是否选取物品 $i$ ，可以求得状态转移方程为：
$$
f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])
$$
​		**含义:**

​		(1) 如果不装第 $i$ 件物品，那么问题就转化为“前 $i-1$ 件物品放入容量为 $j$ 的背包中的最大价值”

​		(2) 如果装第 $i$ 件物品，那么问题就转化为“前 $i-1$ 件物品放入剩下的容量为 $j-v[i]$ 的背包中的最		大价值”

```C++
#include <iostream>
using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            f[i][j] = f[i - 1][j];
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
    }
    cout << f[n][m];
    return 0;
}
```

#### 2. 一维版本

​		观察原来的状态转移方程由于原来的$f[i][j]$都是由它左上角的状态更新过来的，并且仅由$f[i-1]$这一层		状态更新，所以我们可以采用滚动数组的形式，也就是相当于总共就两行状态，第二行状态由第一行状		态更新，第一行状态又由第二行状态更新，如此循环。最后，我们可以将二维数组压缩成一维数组。

​		我们将原来状态转移方程第一维抹除**（但是你脑子里得当做它存在）**，此时的状态转换方程为：
$$
f[j] = max(f[j], f[j - v[i]] + w[i])
$$
​		此时 $f[j]$ 的含义：背包容量 $j$ 下的最优解（最大价值）

​		此时我们得关注遍历顺序，**$i$ 在外层，$j$ 在内层，并且 $j$ 需要逆序遍历！**具体原因可以看这篇题解[01背		包问题--一维动态规划状态转移方程的解释](https://www.acwing.com/solution/content/3982/)

​		此时我们可以采取第一步优化（此处可参考题解[01背包问题（状态转移方程讲解）](https://www.acwing.com/solution/content/1374/)）

```C++
for(int i = 1; i <= n; i++) 
    for(int j = m; j >= 0; j--)
    {
        if(j < v[i]) 
            f[i][j] = f[i - 1][j];  // 优化前
            f[j] = f[j];            // 优化后，该行自动成立，可省略。
        else    
            f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);  // 优化前
            f[j] = max(f[j], f[j - v[i]] + w[i]);                   // 优化后
    }    
```

​		实际上，只有当枚举的背包容量 $>=v[i]$ 时才会更新状态，因此我们可以修改循环终止条件进一步优		化。

```C++
for(int i = 1; i <= n; i++)
{
    for(int j = m; j >= v[i]; j--)  
        f[j] = max(f[j], f[j - v[i]] + w[i]);
} 
```

​		最终我们可以得到一维版本的代码：

```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}
```

## 完全背包问题

### [题目](https://www.acwing.com/problem/content/3/)

![](https://s2.loli.net/2022/03/16/RswkKalOpAFqrQG.png)

### 题解代码

#### 1. 二维版本

​		状态 $f[i][j]$ 的定义与0-1背包是一样的，都是指：前$i$个物品（包括 $i$ ），背包容量 $j$ 下的最优解（最大		价值）

​		首先画出**y氏思考流程图：**![](https://s2.loli.net/2022/03/16/EbzF5YZSHhuIdQf.png)

​		
